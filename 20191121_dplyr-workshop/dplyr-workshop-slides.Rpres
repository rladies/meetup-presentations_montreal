<style>
.reveal code {
    font-family: monospace;
    color: green; 
    font-face: bold; 
}
.reveal h1, .reveal h2, .reveal h3, .reveal h4 {
  word-wrap: normal; 
  -moz-hyphens: none;
  font-size: 45px;
} 
</style>
<style>
.small-code pre code {
  font-size: 1em;
}
</style>
<style>
.footer {
    color: black;
    font-family: Montserrat; 
    font-size: 9px; 
    background: #E8E8E8;
    position: fixed;
    top: 100%;
    text-align:right;
    width:100%; }
</style>

Introduction to data manipulation and visualization in R
======================================================== 
author: Kathryn Morrison 
font-import: http://fonts.googleapis.com/css?family=Montserrat
font-family: 'Montserrat'
date: November 21, 2019 
autosize: true 

Today's Agenda 
========================================================
incremental: true  

Intro <br>
**Part 1: Brief introduction to tidyverse's dplyr** 


Exercises <br>
**Hands-on exercises**


What is base R vs the "tidyverse"? 
========================================================
## **Base R**
 * The original R language, based on S / Splus
 * Mature code 
 * Many underlying libraries written in C/C++/Fortran
 
***
## **tidyverse**
 * Easier to learn and avoids need for SQL 
 * Improves readability of code 
 * Enormous online community of users 
 * Hadley Wickham: **R**-oyalty 


Why learn base R? 
========================================================
incremental: true
 * The 'tidyverse' is very easy to use - you could try to avoid base R as much as possible 
 
 * However, the tidyverse actually only covers a small portion of what can be done in R; it's primarily for data wrangling, but you may need to be familiar with base R to, for example, use advanced modelling libraries
 
 * Base R can also be more performant, so for writing large applications or analyzing large datsetes, it can be worth writing in base R even if it is more tedious 


Introduction to data manipulation in R
========================================================
type: sub-section

 * Base R vs the tidyverse: readability vs performance

 * **Activity II**: Data manipulation with dplyr  

 * What we didnâ€™t cover + where to learn more   

      
Manipulating data with dplyr 
========================================================
incremental: true
<center> ![0.5](slides-figure/pipe.jpg) </center> 
<small> As previously described, the "tidyverse" is a collection of libraries, like `dplyr` that follow some basic coding best practices

`dplyr` is a key tidyverse library that is great for data wrangling 

The pipe opperator allows you to chain together operations in a sequence, avoiding unnecessary temporary tables, and using descriptive functions that are normal english verbs 
</small>

Manipulating data with dplyr 
========================================================
incremental: true
class: small-code

A `tibble` is the tidyverse's version of a data frame. It never changes an input's type (i.e. no conversion of characters to factors) and it allows you to specify variable names outside of the valid R naming rules.
  
```{r}
ds_df <- data.frame(`1 weird name` = 1:3, `is it a factor?` = letters[1:3])
str(ds_df)
library(dplyr)
ds_tib <- tibble(`1 weird name` = 1:3, `is it a factor?` = letters[1:3])
str(ds_tib)
```

Manipulating data with dplyr 
========================================================
incremental: true

<small> Tibbles differ from data frames in two main areas: printing and subsetting 
  * **Printing** a tibble will limit to the first 10 rows and as many columns as fill the console. Extra information on the dimensions, variable types and grouping variables is also included 
  * **Subsetting** rules are stricter than with data frames. Specifically, using the `[` will always return a tibble and never a vector as sometimes happens with a data frame
  
Note that a dataframe passed to a dplyr function will be returned as a tibble; this is usually fine, but not all functions from other packages accept tibbles! Sometimes you will need to transform a tibble back to a data frame with `as.data.frame()`. </small> 

Manipulating data with dplyr 
========================================================

<center> ![](slides-figure/pipe.jpg) </center> 

We will be learning: select(), arrange(), filter(), mutate(), join(),  group_by(), gather(), and spread() 

Let's go through some examples - it's the easiest way to understand and learn 



Reviewing the data 
========================================================

```{r}
library(dplyr)
library(datasets)
ds <- esoph
str(ds)
```


Reviewing the data 
========================================================
class: small-code

```{r}
summary(ds) 
```

select() 
========================================================
class: small-code

Let's select just three columns: age group, number of cases, number of controls
```{r}
ds %>% select(agegp, ncases, ncontrols) %>% head()
```

arrange() 
========================================================
class: small-code

Let's arrange in descending order of number of cases 
```{r}
ds %>% arrange(desc(ncases)) %>% head()
```


filter() 
========================================================
class: small-code

Let's filter by those who are at least 65 years old.
If we want to save this filter, we can create a new dataframe. 
```{r}
ds_olderadults <- ds %>% filter(agegp >= '65-74') 
ds_olderadults %>% head(3)
```

* Note the ordered factor allows for >= command on a character variable.

 
mutate() 
========================================================
class: small-code

Let's create a new variable that is the odds of the outcome per group. 
```{r}
ds_olderadults <- ds_olderadults %>% mutate(odds = ncases/ncontrols) 
```

To append a variable to the same data frame, assign it with the same name. 


group_by() 
========================================================
class: small-code

What if we wanted to know the average odds per age group? 
```{r}
ds_olderadults %>% group_by(agegp) %>% mutate(mean_odds = mean(odds)) %>% head(3)

```

Activity II: Manipulating data in using dplyr  
========================================================
class: small-code
type: section

Annual data on fertility in the US, between 2003-2018

Level of observation: state, level, and race category of the mother

```{r}
# Data source: https://wonder.cdc.gov/
births_2003_2006 <- readRDS("data/births_2003_2006.rds")
births_2007_2018 <- readRDS("data/births_2007_2018.rds")
names(births_2007_2018)
```

Activity II: Instructions
========================================================
type: section
class: small-code

<small> Using dplyr and the above example datasets, complete the following exercises: <br> <br> 
(1) Bind the two data frames into a single data frame. What are the new dimensions of the data frame? <br> 
(2) Delete the first column of the data with the "Notes"<br>
(3) Remove all observations where Average.LMP.Gestational.Age has missing values <br>
(4) Calculate the average birth weight by state using mutate and summarise. How are the results different? <br>
(5) What were the the states with the 5 highest fertility rates in 2010 (tricky question!) <br> <br>
Useful functions: `bind_rows()`, `select()`, `filter()`, `mutate()`,<br> `summarise()`, `arrange()`, `top_n()` </small> 


Solution: 
========================================================
incremental: true
class: small-code

<small>Bind the two rows together, what are the new dimenions of the data frame? </small>

```{r}
df <- bind_rows(births_2003_2006, births_2007_2018)
dim(df)

#Alternatively
ncol(df)
nrow(df)
```


Solution: 
========================================================
incremental: true
class: small-code

<small> Delete the first column of the data with the "Notes"</small>

```{r}
df %>% select(-Notes) %>% head()

```


Solution: 
========================================================
incremental: true
class: small-code

<small> Remove all observations where Average.LMP.Gestational.Age has missing values </small>

```{r}

df %>% filter(!is.na(Average.LMP.Gestational.Age)) %>% head()

```


Solution: 
========================================================
incremental: true
class: small-code

<small> Calculate the average birth weight by state </small>
```{r}
df %>% group_by(State) %>% 
  mutate(avg_bw = mean(Average.Birth.Weight, na.rm = T)) %>% 
  head(2)

df %>% group_by(State) %>% 
  summarise(avg_bw = mean(Average.Birth.Weight)) %>% 
  head(2)
```

Solution: 
========================================================
incremental: true
class: small-code

<small> What were the the states with the 5 highest fertility rates in 2010? </small> 

```{r}
 df %>% filter(Year == 2010) %>% # restrict to 2010
  group_by(State) %>% # collapse over racial groups
  summarise(avg_fertility = mean(Fertility.Rate)) %>% #calculate new state-level average
  arrange(desc(avg_fertility)) %>% #sort average fertility rates in ascdending order
  top_n(5) %>% #select highest values
  head(5) 
```




Where to learn more 
========================================================


<b> Data analysis and modelling     </b> <br>
R for Data Science by Hadley Wickham & Garrett Grolemund <br>
https://r4ds.had.co.nz/

<b> The inner workings of R     </b> <br>
Advanced R by Hadley Wicham: Free e-book!  <br>
http://adv-r.had.co.nz/



Where to learn more 
========================================================

RStudio "Cheat sheets" are very useful summaries: <br> 
https://rstudio.com/resources/cheatsheets/ 

Topics like: 

* The `apply` functions and optimizing code
* Making web applications with `shiny`
* Package development
* Spatial analysis in R


<!-- put this in the last slide -- use jquery to append page # to all sections -->

<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
<script>

for(i=0;i<$("section").length;i++) {
if(i==0) continue
$("section").eq(i).append("<p style='font-size:20px;position:fixed;right:75px;bottom:40px;'>" + i + "</p>")
}

</script>
